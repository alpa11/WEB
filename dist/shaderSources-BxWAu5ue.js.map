{"version":3,"file":"shaderSources-BxWAu5ue.js","sources":["../src/components/mediaEditor/webgl/shaderSources.ts"],"sourcesContent":["export const vertexShaderSource = `\r\nprecision highp float;\r\n\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform float uAngle;\r\nuniform float uScale;\r\nuniform vec2 uFlip;\r\nuniform vec2 uImageSize;\r\nuniform vec2 uResolution;\r\nuniform vec2 uTranslation;\r\n\r\nvarying highp vec2 vTextureCoord;\r\n\r\nvoid main(void) {\r\n  vec2 position = aVertexPosition;\r\n  // Center to 0,0\r\n  position = position - uImageSize / 2.0;\r\n  // Flip\r\n  position = position * uFlip;\r\n  // Scale\r\n  position *= uScale;\r\n\r\n  // Rotate\r\n  vec2 rotation = vec2(sin(uAngle), cos(uAngle));\r\n  position = vec2(\r\n    position.x * rotation.y + position.y * rotation.x,\r\n    position.y * rotation.y - position.x * rotation.x\r\n  );\r\n\r\n  // Go to canvas center\r\n  position += uResolution / 2.0;\r\n\r\n  // Translate and normalize\r\n  position = ((position + uTranslation) / uResolution) * 2.0 - 1.0;  \r\n\r\n  gl_Position = vec4(position * vec2(1, -1), 0.0, 1.0);\r\n  vTextureCoord = aTextureCoord;\r\n}\r\n`;\r\n\r\nexport const fragmentShaderSource = `\r\nprecision highp float;\r\n\r\nvarying highp vec2 vTextureCoord;\r\n\r\nuniform vec2 uImageSize;\r\n\r\nuniform sampler2D uSampler;\r\n\r\nuniform vec2 uResolution;\r\n\r\nuniform float uEnhance;\r\nuniform float uSaturation;\r\nuniform float uBrightness;\r\nuniform float uContrast;\r\nuniform float uWarmth;\r\nuniform float uFade;\r\nuniform float uShadows;\r\nuniform float uHighlights;\r\nuniform float uVignette;\r\nuniform float uGrain;\r\nuniform float uSharpen;\r\n\r\n\r\n// Constants\r\n\r\nvec3 hsLuminanceWeighting = vec3(0.3, 0.3, 0.3);\r\n// https://www.w3.org/TR/WCAG21/#dfn-relative-luminance\r\nconst vec3 luminosityFactor = vec3(0.2126, 0.7152, 0.0722);\r\n\r\nconst lowp float permTexUnit = 1.0 / 256.0;\r\nconst lowp float permTexUnitHalf = 0.5 / 256.0;\r\nconst lowp float grainsize = 2.3;\r\n\r\n\r\n// Utils\r\n\r\nhighp vec3 rgbToYuv(vec3 rgb){\r\n    highp float y = 0.299*rgb.r + 0.587*rgb.g + 0.114*rgb.b;\r\n    return vec3(y, 0.493*(rgb.b-y), 0.877*(rgb.r-y));\r\n}\r\n\r\nhighp vec3 yuvToRgb(vec3 yuv){\r\n    highp float y = yuv.x;\r\n    highp float u = yuv.y;\r\n    highp float v = yuv.z;\r\n    \r\n    highp vec3 r = vec3(\r\n        y + 1.0/0.877*v,\r\n        y - 0.39393*u - 0.58081*v,\r\n        y + 1.0/0.493*u\r\n    );\r\n    return r;\r\n}\r\n\r\nfloat colorLuminosity(vec3 color) {\r\n  return dot(color, luminosityFactor);\r\n}\r\n\r\nfloat easeInOutSigmoid(float x, float k) {\r\n  x = clamp(x, 0.0, 1.0);\r\n  float sigmoid = 1.0 / (1.0 + exp(-k * (x - 0.5)));\r\n  return sigmoid;\r\n}\r\n\r\nhighp vec4 rnm(in highp vec2 tc) {\r\n  highp float noise = sin(dot(tc,vec2(12.9898,78.233))) * 43758.5453;\r\n  \r\n  highp float noiseR = fract(noise)*2.0-1.0;\r\n  highp float noiseG = fract(noise*1.2154)*2.0-1.0;\r\n  highp float noiseB = fract(noise*1.3453)*2.0-1.0;\r\n  highp float noiseA = fract(noise*1.3647)*2.0-1.0;\r\n  \r\n  return vec4(noiseR,noiseG,noiseB,noiseA);\r\n}\r\n\r\nhighp float fade(in highp float t) {\r\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\r\n}\r\n\r\nhighp float pnoise3D(in highp vec3 p) {\r\n  highp vec3 pi = permTexUnit*floor(p)+permTexUnitHalf;\r\n  highp vec3 pf = fract(p);\r\n  \r\n  // Noise contributions from (x=0, y=0), z=0 and z=1\r\n  highp float perm00 = rnm(pi.xy).a ;\r\n  highp vec3  grad000 = rnm(vec2(perm00, pi.z)).rgb * 4.0 - 1.0;\r\n  highp float n000 = dot(grad000, pf);\r\n  highp vec3  grad001 = rnm(vec2(perm00, pi.z + permTexUnit)).rgb * 4.0 - 1.0;\r\n  highp float n001 = dot(grad001, pf - vec3(0.0, 0.0, 1.0));\r\n  \r\n  // Noise contributions from (x=0, y=1), z=0 and z=1\r\n  highp float perm01 = rnm(pi.xy + vec2(0.0, permTexUnit)).a ;\r\n  highp vec3  grad010 = rnm(vec2(perm01, pi.z)).rgb * 4.0 - 1.0;\r\n  highp float n010 = dot(grad010, pf - vec3(0.0, 1.0, 0.0));\r\n  highp vec3  grad011 = rnm(vec2(perm01, pi.z + permTexUnit)).rgb * 4.0 - 1.0;\r\n  highp float n011 = dot(grad011, pf - vec3(0.0, 1.0, 1.0));\r\n  \r\n  // Noise contributions from (x=1, y=0), z=0 and z=1\r\n  highp float perm10 = rnm(pi.xy + vec2(permTexUnit, 0.0)).a ;\r\n  highp vec3  grad100 = rnm(vec2(perm10, pi.z)).rgb * 4.0 - 1.0;\r\n  highp float n100 = dot(grad100, pf - vec3(1.0, 0.0, 0.0));\r\n  highp vec3  grad101 = rnm(vec2(perm10, pi.z + permTexUnit)).rgb * 4.0 - 1.0;\r\n  highp float n101 = dot(grad101, pf - vec3(1.0, 0.0, 1.0));\r\n  \r\n  // Noise contributions from (x=1, y=1), z=0 and z=1\r\n  highp float perm11 = rnm(pi.xy + vec2(permTexUnit, permTexUnit)).a ;\r\n  highp vec3  grad110 = rnm(vec2(perm11, pi.z)).rgb * 4.0 - 1.0;\r\n  highp float n110 = dot(grad110, pf - vec3(1.0, 1.0, 0.0));\r\n  highp vec3  grad111 = rnm(vec2(perm11, pi.z + permTexUnit)).rgb * 4.0 - 1.0;\r\n  highp float n111 = dot(grad111, pf - vec3(1.0, 1.0, 1.0));\r\n  \r\n  // Blend contributions along x\r\n  highp vec4 n_x = mix(vec4(n000, n001, n010, n011), vec4(n100, n101, n110, n111), fade(pf.x));\r\n  \r\n  // Blend contributions along y\r\n  highp vec2 n_xy = mix(n_x.xy, n_x.zw, fade(pf.y));\r\n  \r\n  // Blend contributions along z\r\n  highp float n_xyz = mix(n_xy.x, n_xy.y, fade(pf.z));\r\n  \r\n  return n_xyz;\r\n}\r\n\r\nlowp vec2 coordRot(in lowp vec2 tc, in lowp float angle) {\r\n  lowp float rotX = ((tc.x * 2.0 - 1.0) * cos(angle)) - ((tc.y * 2.0 - 1.0) * sin(angle));\r\n  lowp float rotY = ((tc.y * 2.0 - 1.0) * cos(angle)) + ((tc.x * 2.0 - 1.0) * sin(angle));\r\n  rotX = rotX * 0.5 + 0.5;\r\n  rotY = rotY * 0.5 + 0.5;\r\n  return vec2(rotX,rotY);\r\n}\r\n\r\n\r\n\r\n// Adjustments\r\n\r\nvec4 brightness(vec4 color, float value) {\r\n  float mag = value * 1.045;\r\n  float exppower = 1.0 + abs(mag);\r\n\r\n  if (mag < 0.0) {\r\n    exppower = 1.0 / exppower;\r\n  }\r\n\r\n  color.r = 1.0 - pow((1.0 - color.r), exppower);\r\n  color.g = 1.0 - pow((1.0 - color.g), exppower);\r\n  color.b = 1.0 - pow((1.0 - color.b), exppower);\r\n  return color;\r\n}\r\n\r\nvec4 contrast(vec4 color, float value) {\r\n  value *= .3;\r\n  return vec4(clamp(0.5 + (1.0 + value) * (color.rgb - 0.5), 0.0, 1.0), color.a);\r\n}\r\n\r\nvec4 saturation(vec4 color, float value) {\r\n  vec3 grayscale = vec3(colorLuminosity(color.rgb));\r\n  return vec4(mix(grayscale, color.rgb, 1.0 + value), color.a);\r\n}\r\n\r\nvec4 warmth(vec4 color, float value) {\r\n  highp vec3 yuvVec;\r\n\r\n  if(value > 0.0) {\r\n      yuvVec = vec3(0.1765, -0.1255, 0.0902);\r\n  }\r\n  else {\r\n      yuvVec = -vec3(0.0588,  0.1569, -0.1255);\r\n  }\r\n  highp vec3 yuvColor = rgbToYuv(color.rgb);\r\n  highp float luma = yuvColor.r;\r\n  highp float curveScale = sin(luma * 3.14159);\r\n  yuvColor += 0.375 * value * curveScale * yuvVec;\r\n\r\n  return vec4(clamp(yuvToRgb(yuvColor), 0.0, 1.0), color.a);\r\n}\r\n\r\nvec4 fade(vec4 color, float value) {\r\n  highp vec3 co1 = vec3(-0.9772);\r\n  highp vec3 co2 = vec3(1.708);\r\n  highp vec3 co3 = vec3(-0.1603);\r\n  highp vec3 co4 = vec3(0.2878);\r\n  \r\n  highp vec3 comp1 = co1 * pow(color.rgb, vec3(3.0));\r\n  highp vec3 comp2 = co2 * pow(color.rgb, vec3(2.0));\r\n  highp vec3 comp3 = co3 * color.rgb;\r\n  highp vec3 comp4 = co4;\r\n  \r\n  highp vec3 finalComponent = comp1 + comp2 + comp3 + comp4;\r\n  highp vec3 difference = finalComponent - color.rgb;\r\n  highp vec3 scalingValue = vec3(0.9);\r\n  \r\n  highp vec3 faded = color.rgb + (difference * scalingValue);\r\n  \r\n  return vec4((color.rgb * (1.0 - value)) + (faded * value), color.a);\r\n}\r\n\r\nvec4 highlights(vec4 color, float highlights, float shadows) {\r\n  mediump float hsLuminance = dot(color.rgb, hsLuminanceWeighting);\r\n\r\n  mediump float shadow = clamp((pow(hsLuminance, 1.0 / shadows) + (-0.76) * pow(hsLuminance, 2.0 / shadows)) - hsLuminance, 0.0, 1.0);\r\n  mediump float highlight = clamp((1.0 - (pow(1.0 - hsLuminance, 1.0 / (2.0 - highlights)) + (-0.8) * pow(1.0 - hsLuminance, 2.0 / (2.0 - highlights)))) - hsLuminance, -1.0, 0.0);\r\n  lowp vec3 hsresult = vec3(0.0, 0.0, 0.0) + ((hsLuminance + shadow + highlight) - 0.0) * ((color.rgb - vec3(0.0, 0.0, 0.0)) / (hsLuminance - 0.0));\r\n  \r\n  mediump float contrastedLuminance = ((hsLuminance - 0.5) * 1.5) + 0.5;\r\n  mediump float whiteInterp = contrastedLuminance * contrastedLuminance * contrastedLuminance;\r\n  mediump float whiteTarget = clamp(highlights, 1.0, 2.0) - 1.0;\r\n  hsresult = mix(hsresult, vec3(1.0), clamp(whiteInterp * whiteTarget, 0.0, 1.0));\r\n\r\n  mediump float invContrastedLuminance = 1.0 - contrastedLuminance;\r\n  mediump float blackInterp = invContrastedLuminance * invContrastedLuminance * invContrastedLuminance;\r\n  mediump float blackTarget = 1.0 - clamp(shadows, 0.0, 1.0);\r\n  hsresult = mix(hsresult, vec3(0.0), clamp(blackInterp * blackTarget, 0.0, 1.0));\r\n\r\n  return vec4(hsresult.rgb, color.a);\r\n}\r\n\r\nvec4 vignette(vec4 color, float value) {\r\n  vec2 coord = vTextureCoord.xy;\r\n\r\n  const lowp float midpoint = 0.7;\r\n  const lowp float fuzziness = 0.62;\r\n  \r\n  lowp float radDist = length(coord - 0.5) / sqrt(0.5);\r\n  lowp float mag = easeInOutSigmoid(radDist * midpoint, fuzziness) * value * 0.645;\r\n  color.rgb = mix(pow(color.rgb, vec3(1.0 / (1.0 - mag))), vec3(0.0), mag * mag);\r\n  return color;\r\n}\r\n\r\nvec4 grain(vec4 color, float value) {\r\n  if(value < 0.001) return color;\r\n  vec2 coord = vTextureCoord.xy;\r\n\r\n  highp vec3 rotOffset = vec3(1.425, 3.892, 5.835);\r\n  highp vec2 rotCoordsR = coordRot(coord, rotOffset.x);\r\n  highp vec3 noise = vec3(pnoise3D(vec3(rotCoordsR * vec2(uImageSize.x / grainsize, uImageSize.y / grainsize),0.0)));\r\n  \r\n  lowp vec3 lumcoeff = vec3(0.299,0.587,0.114);\r\n  lowp float luminance = dot(color.rgb, lumcoeff);\r\n  lowp float lum = smoothstep(0.2, 0.0, luminance);\r\n  lum += luminance;\r\n  \r\n  noise = mix(noise,vec3(0.0),pow(lum,4.0));\r\n  color.rgb = color.rgb + noise * value;\r\n  return color;\r\n}\r\n\r\nvec4 sharpen(float value) {\r\n  vec2 coord = vTextureCoord.xy;\r\n\r\n  vec2 step = 1.0 / uResolution.xy;\r\n\r\n  vec3 texA = texture2D( uSampler, coord + vec2(-step.x, -step.y) * 1.5 ).rgb;\r\n  vec3 texB = texture2D( uSampler, coord + vec2( step.x, -step.y) * 1.5 ).rgb;\r\n  vec3 texC = texture2D( uSampler, coord + vec2(-step.x,  step.y) * 1.5 ).rgb;\r\n  vec3 texD = texture2D( uSampler, coord + vec2( step.x,  step.y) * 1.5 ).rgb;\r\n\r\n  vec3 around = value * (texA + texB + texC + texD);\r\n  vec4 center = texture2D(uSampler, coord);\r\n\r\n  float centerMultiplier = 1.0 + 4.0 * value;\r\n\r\n  return vec4(clamp(center.rgb * centerMultiplier - around, 0.0, 1.0), center.a);\r\n}\r\n\r\n\r\n\r\nvoid main(void) {\r\n  vec4 color = texture2D(uSampler, vTextureCoord);\r\n\r\n  color = sharpen(uSharpen * 0.45 + uEnhance * .15);\r\n  color = grain(color, uGrain * 0.04);\r\n  color = saturation(color, uSaturation + uEnhance * .2);\r\n  color = warmth(color, uWarmth);\r\n  color = fade(color, uFade);\r\n  \r\n  color = highlights(color, (uHighlights + uEnhance * 0.15) * 0.75 + 1.0, (uShadows - uEnhance * 0.075) * 0.55 + 1.0);\r\n  color = contrast(color, uContrast + uEnhance * 0.1);\r\n\r\n  color = brightness(color, uBrightness + uEnhance * .25);\r\n  color = vignette(color, uVignette);\r\n\r\n  gl_FragColor = color;\r\n}\r\n`;\r\n"],"names":["vertexShaderSource","fragmentShaderSource"],"mappings":"AAAO,MAAMA,EAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA0CrBC,EAAuB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;"}